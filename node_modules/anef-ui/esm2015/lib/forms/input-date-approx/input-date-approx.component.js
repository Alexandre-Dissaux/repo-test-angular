/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input-date-approx/input-date-approx.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angular
import { Component, Input } from '@angular/core';
import { FormGroup, Validators } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil, startWith, distinctUntilChanged, } from 'rxjs/operators';
import moment from 'moment';
/**
 * ReactiveForm Date Input - Séjour
 * Composed with a text input for the day, a dropdown for the month, a text input for the year
 * Approximative date option
 */
export class InputDateApproxComponent {
    constructor() {
        this.notifier = new Subject();
        this.unknownMonthItem = { label: 'Inconnu', value: 'i' };
        this.isDateApprox = false;
        /**
         * Is FormGroup required
         */
        this.required = true;
        /**
         * Is FormGroup readonly
         */
        this.readonly = false;
        /**
         * Default date value displayed in readonly mode
         * \@default 'N/A'
         */
        this.defaultDisplay = 'N/A';
        /**
         * FormGroup day control label
         * \@default 'Jour'
         */
        this.dayLabel = 'Jour';
        /**
         * FormGroup day control placeholder
         * \@default 'JJ'
         */
        this.dayPlaceholder = 'JJ';
        /**
         * FormGroup month control label
         * \@default 'Mois'
         */
        this.monthLabel = 'Mois';
        /**
         * FormGroup day control placeholder
         * \@default 'MM'
         */
        this.monthPlaceholder = 'MM';
        /**
         * FormGroup year control label
         * \@default 'Année'
         */
        this.yearLabel = 'Année';
        /**
         * FormGroup year control placeholder
         * \@default 'AAAA'
         */
        this.yearPlaceholder = 'AAAA';
        /**
         * FormGroup month control dropdown options
         * \@default SelectItem[] = [
         * { label: 'Janvier', value: 1 },
         * { label: 'Février', value: 2 },
         * { label: 'Mars', value: 3 },
         * { label: 'Avril', value: 4 },
         * { label: 'Mai', value: 5 },
         * { label: 'Juin', value: 6 },
         * { label: 'Juillet', value: 7 },
         * { label: 'Août', value: 8 },
         * { label: 'Septembre', value: 9 },
         * { label: 'Octobre', value: 10 },
         * { label: 'Novembre', value: 11 },
         * { label: 'Décembre', value: 12 }
         * ]
         */
        this.monthOptions = [
            { label: 'Janvier', value: 1 },
            { label: 'Février', value: 2 },
            { label: 'Mars', value: 3 },
            { label: 'Avril', value: 4 },
            { label: 'Mai', value: 5 },
            { label: 'Juin', value: 6 },
            { label: 'Juillet', value: 7 },
            { label: 'Août', value: 8 },
            { label: 'Septembre', value: 9 },
            { label: 'Octobre', value: 10 },
            { label: 'Novembre', value: 11 },
            { label: 'Décembre', value: 12 }
        ];
        /**
         * FormGroup validation error messages
         * \@default DateErrorMessage = {
         *     day: {
         *       required: 'Le jour est requis',
         *       pattern: 'Le jour doit être un nombre',
         *       length: 'Le jour doit contenir 2 chiffres au maximum',
         *       minMax: 'Le jour doit être compris entre 1 et 31'
         *     },
         *     month: {
         *       required: 'Le mois est requis'
         *     },
         *     year: {
         *       required: 'L\'année est requise',
         *       pattern: 'L\'année doit être un nombre',
         *       length: 'L\'année doit contenir 4 chiffres'
         *     },
         *     invalid: 'La date est invalide',
         *     required: 'Ce champ est obligatoire.'
         *   }
         */
        this.messages = {
            day: {
                required: 'Le jour est requis',
                pattern: 'Le jour doit être un nombre',
                length: 'Le jour doit contenir 2 chiffres au maximum',
                minMax: 'Le jour doit être compris entre 1 et 31'
            },
            month: {
                required: 'Le mois est requis'
            },
            year: {
                required: 'L\'année est requise',
                pattern: 'L\'année doit être un nombre',
                length: 'L\'année doit contenir 4 chiffres'
            },
            invalid: 'La date est invalide',
            required: 'Ce champ est obligatoire.'
        };
        /**
         * Can the date be approximative or not
         * \@default false
         * \@usage [canBeApproximative]="true"
         */
        this.canBeApproximative = false;
        /**
         * FormGroup approximative date label
         * \@default 'Approximative'
         */
        this.dateApproxLabel = 'Approximative';
        /**
         * Approximative date format
         * \@values {known: 'FF/FF/FFFF', dayUnknown: '00/FF/FFFF', dayMonthUnknown: '00/00/FFFF'}
         */
        this.dateApproxMasks = { known: 'FF/FF/FFFF', dayUnknown: '00/FF/FFFF', dayMonthUnknown: '00/00/FFFF' };
        this.crossFieldsMinDateValidator = (/**
         * @param {?} fg
         * @return {?}
         */
        (fg) => {
            /** @type {?} */
            const fields = this.getFields();
            if (moment([fields.year, fields.month, fields.day]).isValid() && !this.formContainsErrors()) {
                if (moment([fields.year, fields.month, fields.day]) < moment(this.minDate, 'DD/MM/YYYY')) {
                    return { tooOld: true };
                }
            }
            return null;
        });
        this.crossFieldsMaxDateValidator = (/**
         * @param {?} fg
         * @return {?}
         */
        (fg) => {
            /** @type {?} */
            const fields = this.getFields();
            if (moment([fields.year, fields.month, fields.day]).isValid() && !this.formContainsErrors()) {
                /** @type {?} */
                const date = moment([fields.year, fields.month, fields.day]);
                if (this.maxDate === 'now' && date > moment() || date > moment(this.maxDate, 'DD/MM/YYYY')) {
                    return { tooFuture: true };
                }
            }
            return null;
        });
        this.crossFieldsDateValidator = (/**
         * @param {?} fg
         * @return {?}
         */
        (fg) => {
            /** @type {?} */
            const fields = this.getFields();
            if (!moment([fields.year, fields.month, fields.day]).isValid()) {
                if (this.areFieldsFilled()) {
                    this.formGroup.get(this.yearName).setErrors({ invalidDate: true }, { emitEvent: true });
                    this.formGroup.get(this.monthName).setErrors({ invalidDate: true }, { emitEvent: true });
                    this.formGroup.get(this.dayName).setErrors({ invalidDate: true }, { emitEvent: true });
                }
                this.formGroup.setErrors({ invalidDate: true });
                if ((this.required || this.yearRequired) && this.areFieldsFilled()) {
                    return { invalidDate: true };
                }
            }
            if (moment([fields.year, fields.month, fields.day]).isValid()) {
                this.formGroup.setErrors(null);
                this.formGroup.get(this.yearName).setErrors(null);
                this.formGroup.get(this.monthName).setErrors(null);
                this.formGroup.get(this.dayName).setErrors(null);
            }
            return null;
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['readonly'] && changes['readonly'].previousValue != changes['readonly'].currentValue) {
            this.setCheckboxStyle(changes['readonly'].currentValue);
            if (this.formGroup.get(this.dateApproxMaskName) && this.formGroup.get(this.dateApproxMaskName).value === this.dateApproxMasks.dayMonthUnknown) {
                this.editMonthOptions(true);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.readonly) {
            this.addDayControlMinMaxValidator();
            this.addFormGroupValidators();
        }
        if (this.canBeApproximative && this.formGroup.get(this.dateApproxCheckboxName)) {
            this.dateApproxCheckboxChange();
            this.monthOptionChange();
        }
    }
    /**
     * @return {?}
     */
    addDayControlMinMaxValidator() {
        /** @type {?} */
        const validatorsArray = [];
        validatorsArray.push(Validators.min(1), Validators.max(31));
        if (this.formGroup.get(this.dayName).validator) {
            validatorsArray.push(this.formGroup.get(this.dayName).validator);
        }
        this.formGroup.get(this.dayName).setValidators(validatorsArray);
        this.formGroup.get(this.dayName).updateValueAndValidity();
    }
    /**
     * @return {?}
     */
    addFormGroupValidators() {
        /** @type {?} */
        const validatorsArray = [];
        validatorsArray.push(this.crossFieldsDateValidator);
        if (this.minDate && this.minDateErrorMessage) {
            validatorsArray.push(this.crossFieldsMinDateValidator);
        }
        if (this.maxDate && this.maxDateErrorMessage) {
            validatorsArray.push(this.crossFieldsMaxDateValidator);
        }
        if (this.formGroup.validator) {
            validatorsArray.push(this.formGroup.validator);
        }
        this.formGroup.setValidators(validatorsArray);
        this.formGroup.updateValueAndValidity();
    }
    /**
     * @private
     * @return {?}
     */
    getFields() {
        return { day: this.formGroup.get(this.dayName).value, month: this.getMonthValue(true), year: this.formGroup.get(this.yearName).value };
    }
    /**
     * @return {?}
     */
    areFieldsEmpty() {
        /** @type {?} */
        const fields = this.getFields();
        return !fields.day && !fields.month && !fields.year;
    }
    /**
     * @return {?}
     */
    areFieldsFilled() {
        /** @type {?} */
        const fields = this.getFields();
        return fields.day != null && fields.month > -1 && fields.year != null;
    }
    /**
     * @return {?}
     */
    areFieldsTouched() {
        return this.formGroup.get(this.yearName).touched && this.formGroup.get(this.yearName).touched && this.formGroup.get(this.yearName).touched;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.notifier.next();
        this.notifier.unsubscribe();
    }
    /**
     * Returns true if form is invalid
     * @return {?}
     */
    formContainsErrors() {
        /** @type {?} */
        const controlNames = [this.dayName, this.monthName, this.yearName];
        return controlNames.some((/**
         * @param {?} controlName
         * @return {?}
         */
        controlName => {
            return this.controlContainsErrors(controlName);
        }));
    }
    /**
     * @return {?}
     */
    formError() {
        return this.formGroup.touched && this.formGroup.errors !== null;
    }
    /**
     * Returns true if a control is invalid
     * @param {?} controlName
     * @return {?}
     */
    controlContainsErrors(controlName) {
        return this.formGroup && (this.formGroup.controls[controlName].errors !== null && (this.formGroup.controls[controlName].dirty || this.formGroup.controls[controlName].touched));
    }
    /**
     * Returns true if control value has pattern errors
     * @param {?} controlName
     * @return {?}
     */
    hasPatternError(controlName) {
        return this.controlContainsErrors(controlName) && this.formGroup.controls[controlName].errors.pattern;
    }
    /**
     * Returns true if control value is inferior to control min value or superior to control max value
     * @param {?} controlName
     * @return {?}
     */
    hasMinMaxError(controlName) {
        return this.controlContainsErrors(controlName) &&
            (this.formGroup.controls[controlName].errors.min || this.formGroup.controls[controlName].errors.max);
    }
    /**
     * Returns true if control value length is inferior to control min value length or superior to control max value length
     * @param {?} controlName
     * @return {?}
     */
    hasLengthError(controlName) {
        return this.controlContainsErrors(controlName) &&
            (this.formGroup.controls[controlName].errors.minlength || this.formGroup.controls[controlName].errors.maxlength);
    }
    /**
     * Returns true if control is required but not filled
     * @param {?} controlName
     * @return {?}
     */
    hasRequiredError(controlName) {
        return this.controlContainsErrors(controlName) && this.formGroup.controls[controlName].errors.required;
    }
    /**
     * Returns true if control is not a valid date
     * @param {?} controlName
     * @return {?}
     */
    hasInvalidDateError(controlName) {
        return this.controlContainsErrors(controlName) && this.formGroup.controls[controlName].errors.invalidDate;
    }
    /**
     * Returns true if form does not have a valid date
     * @return {?}
     */
    hasFormGroupInvalidateError() {
        return this.formGroup.errors && this.formGroup.errors.invalidDate;
    }
    /**
     * @return {?}
     */
    hasFutureDateError() {
        return this.formGroup.errors && this.formGroup.errors.tooFuture;
    }
    /**
     * @return {?}
     */
    hasTooOldDateError() {
        return this.formGroup.errors && this.formGroup.errors.tooOld;
    }
    /**
     * @return {?}
     */
    isAllFieldsFilled() {
        return this.hasRequiredError(this.yearName)
            && this.hasRequiredError(this.monthName)
            && this.hasRequiredError(this.dayName);
    }
    /**
     * Returns FormGroup month field value
     * @private
     * @param {?=} correctForMoment
     * @return {?}
     */
    getMonthValue(correctForMoment) {
        /** @type {?} */
        let value = this.formGroup.get(this.monthName).value;
        if (value === this.unknownMonthItem.value) {
            value = 1;
        }
        if (correctForMoment) {
            return value - 1;
        }
        return value;
    }
    /**
     * Format date to string for display
     * @return {?}
     */
    toString() {
        /** @type {?} */
        let dateString;
        /** @type {?} */
        const day = this.formGroup.get(this.dayName).value;
        /** @type {?} */
        const month = this.formGroup.get(this.monthName).value;
        /** @type {?} */
        const year = this.formGroup.get(this.yearName).value;
        /** @type {?} */
        const nonApproxAndEmpty = !this.isDateApprox && !day && !month && !year;
        /** @type {?} */
        const approxAndEmpty = this.isDateApprox && !month && !year;
        if (nonApproxAndEmpty || approxAndEmpty) {
            dateString = this.defaultDisplay;
        }
        else {
            moment.updateLocale(moment.locale(), { invalidDate: this.defaultDisplay });
            dateString = moment([Number(year), Number(this.getMonthValue(true)), Number(day)]).format('DD/MM/YYYY');
            if (!nonApproxAndEmpty && !this.isDateApprox) {
                return dateString;
            }
            else if (!approxAndEmpty && this.isDateApprox) {
                /** @type {?} */
                const mask = this.formGroup.get(this.dateApproxMaskName).value;
                /** @type {?} */
                const dateStringArray = dateString.split('/');
                if (mask === this.dateApproxMasks.dayUnknown) {
                    dateStringArray[0] = '-';
                }
                else if (mask === this.dateApproxMasks.dayMonthUnknown) {
                    dateStringArray[0] = '-';
                    dateStringArray[1] = '-';
                }
                dateString = dateStringArray.join('/');
            }
        }
        return dateString;
    }
    /**
     * Triggers date approx editing functions following date approx checkbox values
     * @private
     * @return {?}
     */
    dateApproxCheckboxChange() {
        this.formGroup.get(this.dateApproxCheckboxName).valueChanges
            .pipe(startWith(this.formGroup.get(this.dateApproxCheckboxName).value), distinctUntilChanged(), takeUntil(this.notifier))
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.isDateApprox = value;
            this.setDayValue(value);
            this.editMonthOptions(value);
            this.setDateApproxMask(value);
        }));
    }
    /**
     * Triggers SetDateApproxMAsk on monthOptions change
     * @private
     * @return {?}
     */
    monthOptionChange() {
        this.formGroup.get(this.monthName).valueChanges
            .pipe(startWith(this.formGroup.get(this.monthName).value), distinctUntilChanged(), takeUntil(this.notifier))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.setDateApproxMask(this.isDateApprox);
            this.formGroup.updateValueAndValidity();
        }));
    }
    /**
     * Sets day value to 1 if date is approximative
     * @private
     * @param {?} value
     * @return {?}
     */
    setDayValue(value) {
        if (value) {
            this.formGroup.get(this.dayName).setValue('1');
        }
        else {
            if (this.formGroup.get(this.dateApproxCheckboxName).dirty) {
                this.formGroup.get(this.dayName).reset();
            }
        }
    }
    /**
     * Adds or remove 'Inconnu' month option
     * @private
     * @param {?} value
     * @return {?}
     */
    editMonthOptions(value) {
        /** @type {?} */
        const hasUnknownMonthItem = this.monthOptions.some((/**
         * @param {?} item
         * @return {?}
         */
        item => item.value === this.unknownMonthItem.value));
        if (value) {
            if (!hasUnknownMonthItem) {
                this.monthOptions.unshift(this.unknownMonthItem);
            }
            if (this.formGroup.get(this.dateApproxMaskName).value === this.dateApproxMasks.dayMonthUnknown) {
                this.formGroup.get(this.monthName).setValue(this.unknownMonthItem.value);
            }
        }
        else {
            if (hasUnknownMonthItem) {
                this.monthOptions.shift();
            }
            if (this.formGroup.get(this.monthName).value === this.unknownMonthItem.value) {
                this.formGroup.get(this.monthName).reset();
            }
        }
    }
    /**
     * Sets date approx mask
     * @private
     * @param {?} value
     * @return {?}
     */
    setDateApproxMask(value) {
        /** @type {?} */
        const dateApproxMaskName = this.formGroup.get(this.dateApproxMaskName);
        if (value) {
            if (this.formGroup.get(this.monthName).value === this.unknownMonthItem.value) {
                dateApproxMaskName.setValue(this.dateApproxMasks.dayMonthUnknown);
            }
            else {
                dateApproxMaskName.setValue(this.dateApproxMasks.dayUnknown);
            }
        }
        else {
            dateApproxMaskName.setValue(this.dateApproxMasks.known);
        }
    }
    /**
     * Set approx checkbox style in readonly mode
     * @private
     * @param {?} isReadOnly
     * @return {?}
     */
    setCheckboxStyle(isReadOnly) {
        if (this.canBeApproximative && this.formGroup.get(this.dateApproxCheckboxName)) {
            if (isReadOnly) {
                this.formGroup.get(this.dateApproxCheckboxName).disable();
            }
            else {
                this.formGroup.get(this.dateApproxCheckboxName).enable();
            }
        }
    }
}
InputDateApproxComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: 'anef-input-date-approx',
                template: "<div class=\"p-grid nogutter\" [formGroup]=\"formGroup\">\n  <div class=\"p-col-12\">\n    <fieldset>\n      <div class=\"p-grid nogutter\" *ngIf=\"canBeApproximative; else dateCannotBeApproximative\">\n        <div class=\"p-col-8\">\n          <legend *ngIf=\"label\">\n            {{ label }} <span class=\"redish\" *ngIf=\"required\">*</span> :\n          </legend>\n        </div>\n        <div class=\"p-col-4\">\n          <p-checkbox\n                [name]=\"dateApproxCheckboxName\"\n                value=\"true\"\n                binary=\"true\"\n                [label]=\"dateApproxLabel\"\n                [formControlName]=\"dateApproxCheckboxName\"\n                checkboxIcon=\"pi pi-check\"\n                >\n          </p-checkbox>\n\n        </div>\n      </div>\n      <ng-template #dateCannotBeApproximative>\n        <legend *ngIf=\"label\">\n          {{ label }} <span class=\"redish\" *ngIf=\"required\">*</span> :\n        </legend>\n      </ng-template>\n\n      <ng-content select=\"[sub-label]\"></ng-content>\n      <input *ngIf=\"isDateApprox\" pInputText type=\"hidden\" [id]=\"dateApproxMaskName\" [name]=\"dateApproxMaskName\" [formControlName]=\"dateApproxMaskName\">\n\n      <div *ngIf=\"!readonly; else textual\" class=\"p-grid\">\n        <div class=\"p-col-12 p-md-2\">\n          <div class=\"p-grid nogutter\">\n            <div class=\"p-col-12\">\n              <label id=\"dayHelpBlock\">{{ dayLabel }} :\n              </label>\n              <input pInputText [id]=\"dayName\" [name]=\"dayName\" type=\"text\" class=\"day\"\n                     placeholder=\"{{dayPlaceholder}}\" aria-describedby=\"dayHelpBlock\" [hidden]=\"isDateApprox\"\n                     [formControlName]=\"dayName\" pattern=\"[0-9]{0,2}\" min=\"1\" max=\"31\" maxlength=\"2\">\n\n              <input *ngIf=\"isDateApprox\" pInputText id=\"dayApproxName\" name=\"dayApproxName\" type=\"text\" class=\"day\"\n              placeholder=\" \" aria-describedby=\"dayHelpBlock\" disabled=\"true\">\n            </div>\n          </div>\n        </div>\n        <div class=\"p-col-12 p-md-6\">\n          <div class=\"p-grid nogutter\">\n            <div class=\"p-col-12\">\n              <label id=\"monthHelpBlock\">{{ monthLabel }} :\n              </label>\n              <p-dropdown class=\"month-dropdown\" [id]=\"monthName\" [name]=\"monthName\" aria-describedby=\"monthHelpBlock\"\n                          [placeholder]=monthPlaceholder [options]=monthOptions\n                          [formControlName]=\"monthName\" >\n              </p-dropdown>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"p-col-12 p-md-4\">\n          <div class=\"p-grid nogutter\">\n            <div class=\"p-col-12\">\n              <label id=\"yearHelpBlock\">{{ yearLabel}}\n                <span class=\"redish\" *ngIf=\"yearRequired\"> *</span> :\n              </label>\n              <input pInputText [id]=\"yearName\" [name]=\"yearName\" type=\"text\" placeholder=\"{{ yearPlaceholder }}\"\n                     pattern=\"[0-9]{0,4}\" minlength=\"4\" maxlength=\"4\"\n                     aria-describedby=\"yearHelpBlock\" [formControlName]=\"yearName\">\n            </div>\n          </div>\n        </div>\n      </div>\n      <ng-template #textual>\n        <span class=\"textual\">{{toString()}}</span>\n      </ng-template>\n\n      <ng-content select=\"[complement]\"></ng-content>\n\n      <div class=\"redish errors\" *ngIf=\"(formContainsErrors() || formGroup.errors) && !isAllFieldsFilled(); else dateRequired\">\n        <div *ngIf=\"controlContainsErrors(dayName)\">\n          <div *ngIf=\"hasPatternError(dayName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.day.pattern}}\n            </span>\n          </div>\n          <div *ngIf=\"hasMinMaxError(dayName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.day.minMax}}\n            </span>\n          </div>\n          <div *ngIf=\"hasLengthError(dayName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.day.length}}\n            </span>\n          </div>\n          <div *ngIf=\"hasRequiredError(dayName) && !hasPatternError(dayName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.day.required}}\n            </span>\n          </div>\n        </div>\n        <div *ngIf=\"controlContainsErrors(monthName)\">\n          <div *ngIf=\"hasRequiredError(monthName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.month.required}}\n            </span>\n          </div>\n        </div>\n        <div *ngIf=\"controlContainsErrors(yearName)\">\n          <div *ngIf=\"hasPatternError(yearName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.year.pattern}}\n            </span>\n          </div>\n          <div *ngIf=\"hasLengthError(yearName) && !hasPatternError(yearName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.year.length}}\n            </span>\n          </div>\n          <div *ngIf=\"hasRequiredError(yearName) && !hasPatternError(yearName)\">\n            <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            <span>\n              {{messages.year.required}}\n            </span>\n          </div>\n        </div>\n\n        <div *ngIf=\"hasFormGroupInvalidateError()\"><i\n          class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n          <span>\n              {{messages.invalid}}\n          </span>\n        </div>\n\n        <div *ngIf=\"hasTooOldDateError()\"><i\n          class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n          <span>\n              {{minDateErrorMessage}}\n          </span>\n        </div>\n\n\n        <div *ngIf=\"hasFutureDateError()\"><i\n          class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n          <span>\n              {{maxDateErrorMessage}}\n          </span>\n        </div>\n\n        <ng-content select=\"[messages]\"></ng-content>\n      </div>\n      <ng-template #dateRequired >\n        <div class=\"redish errors\" *ngIf=\"isAllFieldsFilled()\">\n          <i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>\n          <span>\n            {{messages.required}}\n          </span>\n        </div>\n      </ng-template>\n    </fieldset>\n  </div>\n</div>\n",
                styles: [".textual{display:block}.day{padding-left:1rem;padding-right:1rem;min-width:4rem}#dayHelpBlock{white-space:nowrap}fieldset{border-color:transparent;border-width:0;padding:0}legend{-webkit-padding-start:0;padding-inline-start:0;padding-bottom:1rem}.p-grid label{margin:0;color:#656565}body .ui-dropdown-panel .ui-dropdown-items .ui-dropdown-item span:first{color:#656565}::-webkit-input-placeholder{color:#111}:-moz-placeholder{color:#111}::-moz-placeholder{color:#111}:-ms-input-placeholder{color:#111}"]
            }] }
];
/** @nocollapse */
InputDateApproxComponent.ctorParameters = () => [];
InputDateApproxComponent.propDecorators = {
    formGroup: [{ type: Input }],
    label: [{ type: Input }],
    required: [{ type: Input }],
    readonly: [{ type: Input }],
    defaultDisplay: [{ type: Input }],
    dayName: [{ type: Input }],
    dayLabel: [{ type: Input }],
    dayPlaceholder: [{ type: Input }],
    monthName: [{ type: Input }],
    monthLabel: [{ type: Input }],
    monthPlaceholder: [{ type: Input }],
    yearName: [{ type: Input }],
    yearRequired: [{ type: Input }],
    yearLabel: [{ type: Input }],
    yearPlaceholder: [{ type: Input }],
    model: [{ type: Input }],
    monthOptions: [{ type: Input }],
    messages: [{ type: Input }],
    canBeApproximative: [{ type: Input }],
    dateApproxLabel: [{ type: Input }],
    dateApproxCheckboxName: [{ type: Input }],
    dateApproxMasks: [{ type: Input }],
    dateApproxMaskName: [{ type: Input }],
    maxDate: [{ type: Input }],
    maxDateErrorMessage: [{ type: Input }],
    minDate: [{ type: Input }],
    minDateErrorMessage: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    InputDateApproxComponent.prototype.notifier;
    /**
     * @type {?}
     * @private
     */
    InputDateApproxComponent.prototype.unknownMonthItem;
    /** @type {?} */
    InputDateApproxComponent.prototype.isDateApprox;
    /**
     * FormGroup name
     * @type {?}
     */
    InputDateApproxComponent.prototype.formGroup;
    /**
     * FormGroup label
     * @type {?}
     */
    InputDateApproxComponent.prototype.label;
    /**
     * Is FormGroup required
     * @type {?}
     */
    InputDateApproxComponent.prototype.required;
    /**
     * Is FormGroup readonly
     * @type {?}
     */
    InputDateApproxComponent.prototype.readonly;
    /**
     * Default date value displayed in readonly mode
     * \@default 'N/A'
     * @type {?}
     */
    InputDateApproxComponent.prototype.defaultDisplay;
    /**
     * FormGroup day control name
     * @type {?}
     */
    InputDateApproxComponent.prototype.dayName;
    /**
     * FormGroup day control label
     * \@default 'Jour'
     * @type {?}
     */
    InputDateApproxComponent.prototype.dayLabel;
    /**
     * FormGroup day control placeholder
     * \@default 'JJ'
     * @type {?}
     */
    InputDateApproxComponent.prototype.dayPlaceholder;
    /**
     * FormGroup month control name
     * @type {?}
     */
    InputDateApproxComponent.prototype.monthName;
    /**
     * FormGroup month control label
     * \@default 'Mois'
     * @type {?}
     */
    InputDateApproxComponent.prototype.monthLabel;
    /**
     * FormGroup day control placeholder
     * \@default 'MM'
     * @type {?}
     */
    InputDateApproxComponent.prototype.monthPlaceholder;
    /**
     * FormGroup year control name
     * @type {?}
     */
    InputDateApproxComponent.prototype.yearName;
    /**
     * Puts a required * mark aside the year control
     * @type {?}
     */
    InputDateApproxComponent.prototype.yearRequired;
    /**
     * FormGroup year control label
     * \@default 'Année'
     * @type {?}
     */
    InputDateApproxComponent.prototype.yearLabel;
    /**
     * FormGroup year control placeholder
     * \@default 'AAAA'
     * @type {?}
     */
    InputDateApproxComponent.prototype.yearPlaceholder;
    /**
     * model property for usage with ngModel to be defined
     * @type {?}
     */
    InputDateApproxComponent.prototype.model;
    /**
     * FormGroup month control dropdown options
     * \@default SelectItem[] = [
     * { label: 'Janvier', value: 1 },
     * { label: 'Février', value: 2 },
     * { label: 'Mars', value: 3 },
     * { label: 'Avril', value: 4 },
     * { label: 'Mai', value: 5 },
     * { label: 'Juin', value: 6 },
     * { label: 'Juillet', value: 7 },
     * { label: 'Août', value: 8 },
     * { label: 'Septembre', value: 9 },
     * { label: 'Octobre', value: 10 },
     * { label: 'Novembre', value: 11 },
     * { label: 'Décembre', value: 12 }
     * ]
     * @type {?}
     */
    InputDateApproxComponent.prototype.monthOptions;
    /**
     * FormGroup validation error messages
     * \@default DateErrorMessage = {
     *     day: {
     *       required: 'Le jour est requis',
     *       pattern: 'Le jour doit être un nombre',
     *       length: 'Le jour doit contenir 2 chiffres au maximum',
     *       minMax: 'Le jour doit être compris entre 1 et 31'
     *     },
     *     month: {
     *       required: 'Le mois est requis'
     *     },
     *     year: {
     *       required: 'L\'année est requise',
     *       pattern: 'L\'année doit être un nombre',
     *       length: 'L\'année doit contenir 4 chiffres'
     *     },
     *     invalid: 'La date est invalide',
     *     required: 'Ce champ est obligatoire.'
     *   }
     * @type {?}
     */
    InputDateApproxComponent.prototype.messages;
    /**
     * Can the date be approximative or not
     * \@default false
     * \@usage [canBeApproximative]="true"
     * @type {?}
     */
    InputDateApproxComponent.prototype.canBeApproximative;
    /**
     * FormGroup approximative date label
     * \@default 'Approximative'
     * @type {?}
     */
    InputDateApproxComponent.prototype.dateApproxLabel;
    /**
     * FormGroup approximative date checkbox control name, required if approximative date
     * @type {?}
     */
    InputDateApproxComponent.prototype.dateApproxCheckboxName;
    /**
     * Approximative date format
     * \@values {known: 'FF/FF/FFFF', dayUnknown: '00/FF/FFFF', dayMonthUnknown: '00/00/FFFF'}
     * @type {?}
     */
    InputDateApproxComponent.prototype.dateApproxMasks;
    /**
     * FormGroup approximative date mask hidden control name, required if approximative date
     * @type {?}
     */
    InputDateApproxComponent.prototype.dateApproxMaskName;
    /**
     * max value for date DD/MM/YYY or 'now'
     * @type {?}
     */
    InputDateApproxComponent.prototype.maxDate;
    /**
     * Error message if date > max value
     * @type {?}
     */
    InputDateApproxComponent.prototype.maxDateErrorMessage;
    /**
     * min value for date DD/MM/YYY
     * @type {?}
     */
    InputDateApproxComponent.prototype.minDate;
    /**
     * Error message if date < min value
     * @type {?}
     */
    InputDateApproxComponent.prototype.minDateErrorMessage;
    /** @type {?} */
    InputDateApproxComponent.prototype.crossFieldsMinDateValidator;
    /** @type {?} */
    InputDateApproxComponent.prototype.crossFieldsMaxDateValidator;
    /** @type {?} */
    InputDateApproxComponent.prototype.crossFieldsDateValidator;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZGF0ZS1hcHByb3guY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5lZi11aS8iLCJzb3VyY2VzIjpbImxpYi9mb3Jtcy9pbnB1dC1kYXRlLWFwcHJveC9pbnB1dC1kYXRlLWFwcHJveC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQStDLE1BQU0sZUFBZSxDQUFDO0FBQzlGLE9BQU8sRUFBRSxTQUFTLEVBQWUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHcEUsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxvQkFBb0IsR0FBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVFLE9BQU8sTUFBTSxNQUFNLFFBQVEsQ0FBQztBQVU1Qjs7OztHQUlHO0FBQ0gsTUFBTSxPQUFPLHdCQUF3QjtJQTRLbkM7UUEzS1EsYUFBUSxHQUFpQixJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ3ZDLHFCQUFnQixHQUFHLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFDLENBQUM7UUFDMUQsaUJBQVksR0FBRyxLQUFLLENBQUM7Ozs7UUFTWixhQUFRLEdBQUcsSUFBSSxDQUFDOzs7O1FBR2hCLGFBQVEsR0FBRyxLQUFLLENBQUM7Ozs7O1FBS2pCLG1CQUFjLEdBQUcsS0FBSyxDQUFDOzs7OztRQVF2QixhQUFRLEdBQUcsTUFBTSxDQUFDOzs7OztRQUtsQixtQkFBYyxHQUFHLElBQUksQ0FBQzs7Ozs7UUFRdEIsZUFBVSxHQUFHLE1BQU0sQ0FBQzs7Ozs7UUFLcEIscUJBQWdCLEdBQUcsSUFBSSxDQUFDOzs7OztRQVd4QixjQUFTLEdBQUcsT0FBTyxDQUFDOzs7OztRQUtwQixvQkFBZSxHQUFHLE1BQU0sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBc0J6QixpQkFBWSxHQUFpQjtZQUNwQyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUM5QixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUM5QixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUMzQixFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUM1QixFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUMxQixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUMzQixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUM5QixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUMzQixFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUNoQyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUMvQixFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUNoQyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRTtTQUNqQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBc0JPLGFBQVEsR0FBcUI7WUFDcEMsR0FBRyxFQUFFO2dCQUNILFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLE9BQU8sRUFBRSw2QkFBNkI7Z0JBQ3RDLE1BQU0sRUFBRSw2Q0FBNkM7Z0JBQ3JELE1BQU0sRUFBRSx5Q0FBeUM7YUFDbEQ7WUFDRCxLQUFLLEVBQUU7Z0JBQ0wsUUFBUSxFQUFFLG9CQUFvQjthQUMvQjtZQUNELElBQUksRUFBRTtnQkFDSixRQUFRLEVBQUUsc0JBQXNCO2dCQUNoQyxPQUFPLEVBQUUsOEJBQThCO2dCQUN2QyxNQUFNLEVBQUUsbUNBQW1DO2FBQzVDO1lBQ0QsT0FBTyxFQUFFLHNCQUFzQjtZQUMvQixRQUFRLEVBQUUsMkJBQTJCO1NBQ3RDLENBQUM7Ozs7OztRQU1PLHVCQUFrQixHQUFHLEtBQUssQ0FBQzs7Ozs7UUFLM0Isb0JBQWUsR0FBRyxlQUFlLENBQUM7Ozs7O1FBUWxDLG9CQUFlLEdBQUcsRUFBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBQyxDQUFDO1FBd0UxRyxnQ0FBMkI7Ozs7UUFBZ0IsQ0FBQyxFQUFhLEVBQUUsRUFBRTs7a0JBQ3JELE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQy9CLElBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEVBQUM7Z0JBQ3pGLElBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxFQUFFO29CQUN2RixPQUFPLEVBQUUsTUFBTSxFQUFHLElBQUksRUFBRSxDQUFBO2lCQUN6QjthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLEVBQUE7UUFFRCxnQ0FBMkI7Ozs7UUFBZ0IsQ0FBQyxFQUFhLEVBQUUsRUFBRTs7a0JBQ3JELE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQy9CLElBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEVBQUM7O3NCQUNuRixJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDNUQsSUFBRyxJQUFJLENBQUMsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEdBQUcsTUFBTSxFQUFFLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxFQUFFO29CQUN6RixPQUFPLEVBQUUsU0FBUyxFQUFHLElBQUksRUFBRSxDQUFBO2lCQUM1QjthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLEVBQUE7UUFvQkQsNkJBQXdCOzs7O1FBQWdCLENBQUMsRUFBYSxFQUFFLEVBQUU7O2tCQUNsRCxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUMvQixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUM5RCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBQztvQkFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO29CQUN4RixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQ3pGLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztpQkFDeEY7Z0JBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztnQkFFaEQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBRSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRTtvQkFDbkUsT0FBTyxFQUFFLFdBQVcsRUFBRyxJQUFJLEVBQUUsQ0FBQztpQkFDL0I7YUFDRjtZQUNELElBQUksTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFDO2dCQUM1RCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNsRDtZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxFQUFBO0lBcEhjLENBQUM7Ozs7O0lBQ2hCLFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxZQUFZLEVBQUU7WUFDaEcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN4RCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsRUFBRTtnQkFFN0ksSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzdCO1NBQ0Y7SUFDSCxDQUFDOzs7O0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2xCLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1NBQy9CO1FBRUQsSUFBSSxJQUFJLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEVBQUU7WUFDOUUsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7WUFDaEMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7U0FDMUI7SUFDSCxDQUFDOzs7O0lBRUQsNEJBQTRCOztjQUNwQixlQUFlLEdBQUcsRUFBRTtRQUUxQixlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBRTNELElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRTtZQUM5QyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNsRTtRQUVELElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLHNCQUFzQixFQUFFLENBQUM7SUFDNUQsQ0FBQzs7OztJQUVELHNCQUFzQjs7Y0FDZCxlQUFlLEdBQUcsRUFBRTtRQUUxQixlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBRXBELElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDNUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsQ0FBQTtTQUN2RDtRQUNELElBQUcsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDM0MsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsQ0FBQTtTQUN2RDtRQUNELElBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUU7WUFDM0IsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFBO1NBQy9DO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQzFDLENBQUM7Ozs7O0lBdUJPLFNBQVM7UUFDZixPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtJQUN4SSxDQUFDOzs7O0lBRUQsY0FBYzs7Y0FDTixNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUMvQixPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO0lBQ3RELENBQUM7Ozs7SUFFRCxlQUFlOztjQUNQLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQy9CLE9BQU8sTUFBTSxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztJQUN4RSxDQUFDOzs7O0lBRUQsZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUM3SSxDQUFDOzs7O0lBMEJELFdBQVc7UUFDVCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDOUIsQ0FBQzs7Ozs7SUFHRCxrQkFBa0I7O2NBQ1YsWUFBWSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDbEUsT0FBTyxZQUFZLENBQUMsSUFBSTs7OztRQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ3JDLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFBO1FBQUMsQ0FBQyxFQUFDLENBQUU7SUFDdkQsQ0FBQzs7OztJQUVELFNBQVM7UUFDTixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQztJQUNuRSxDQUFDOzs7Ozs7SUFHRCxxQkFBcUIsQ0FBQyxXQUFtQjtRQUN2QyxPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDbEwsQ0FBQzs7Ozs7O0lBRUQsZUFBZSxDQUFDLFdBQW1CO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7SUFDeEcsQ0FBQzs7Ozs7O0lBRUQsY0FBYyxDQUFDLFdBQW1CO1FBQ2hDLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQztZQUM1QyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pHLENBQUM7Ozs7OztJQUVELGNBQWMsQ0FBQyxXQUFtQjtRQUNoQyxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUM7WUFDNUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNySCxDQUFDOzs7Ozs7SUFFRCxnQkFBZ0IsQ0FBQyxXQUFtQjtRQUNsQyxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO0lBQ3pHLENBQUM7Ozs7OztJQUVELG1CQUFtQixDQUFDLFdBQW1CO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUM7SUFDNUcsQ0FBQzs7Ozs7SUFHRCwyQkFBMkI7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUM7SUFDcEUsQ0FBQzs7OztJQUVELGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNsRSxDQUFDOzs7O0lBRUQsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBRS9ELENBQUM7Ozs7SUFFRCxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2VBQ3BDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO2VBQ3JDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0MsQ0FBQzs7Ozs7OztJQUdPLGFBQWEsQ0FBQyxnQkFBMEI7O1lBQ3pDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSztRQUNyRCxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFO1lBQ3pDLEtBQUssR0FBRyxDQUFDLENBQUM7U0FDWDtRQUNELElBQUksZ0JBQWdCLEVBQUU7WUFDcEIsT0FBTyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDOzs7OztJQUdELFFBQVE7O1lBQ0YsVUFBa0I7O2NBRWhCLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSzs7Y0FDNUMsS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLOztjQUNoRCxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUs7O2NBRTlDLGlCQUFpQixHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUk7O2NBQ2pFLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSTtRQUUzRCxJQUFJLGlCQUFpQixJQUFJLGNBQWMsRUFBRTtZQUN2QyxVQUFVLEdBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQztTQUNuQzthQUFNO1lBQ0wsTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7WUFDM0UsVUFBVSxHQUFHLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRXhHLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQzVDLE9BQU8sVUFBVSxDQUFDO2FBQ25CO2lCQUFNLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTs7c0JBQ3pDLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxLQUFLOztzQkFDeEQsZUFBZSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUM3QyxJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRTtvQkFDNUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztpQkFDMUI7cUJBQU0sSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDLGVBQWUsQ0FBQyxlQUFlLEVBQUU7b0JBQ3hELGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7b0JBQ3pCLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7aUJBQzFCO2dCQUNELFVBQVUsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3hDO1NBQ0Y7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDOzs7Ozs7SUFHTyx3QkFBd0I7UUFDOUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsWUFBWTthQUMzRCxJQUFJLENBQ0gsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUNoRSxvQkFBb0IsRUFBRSxFQUN0QixTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUN2QjthQUNGLFNBQVM7Ozs7UUFBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ25CLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDeEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QixDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQUdPLGlCQUFpQjtRQUN2QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsWUFBWTthQUM5QyxJQUFJLENBQ0gsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFDbkQsb0JBQW9CLEVBQUUsRUFDdEIsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FDdkI7YUFDRixTQUFTOzs7UUFBQyxHQUFHLEVBQUU7WUFDZCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzFDLElBQUksQ0FBQyxTQUFTLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztRQUN4QyxDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7Ozs7SUFHTyxXQUFXLENBQUMsS0FBYztRQUNoQyxJQUFJLEtBQUssRUFBRTtZQUNULElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDaEQ7YUFBTTtZQUNMLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsS0FBSyxFQUFFO2dCQUN6RCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDMUM7U0FDRjtJQUNILENBQUM7Ozs7Ozs7SUFHTyxnQkFBZ0IsQ0FBQyxLQUFjOztjQUMvQixtQkFBbUIsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUk7Ozs7UUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBQztRQUN2RyxJQUFJLEtBQUssRUFBRTtZQUNULElBQUksQ0FBQyxtQkFBbUIsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDbEQ7WUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsRUFBRTtnQkFDOUYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDMUU7U0FDRjthQUFNO1lBQ0wsSUFBSSxtQkFBbUIsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUMzQjtZQUNELElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFO2dCQUM1RSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDNUM7U0FDRjtJQUNILENBQUM7Ozs7Ozs7SUFHTyxpQkFBaUIsQ0FBQyxLQUFjOztjQUNoQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUM7UUFDdEUsSUFBSSxLQUFLLEVBQUU7WUFDVCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRTtnQkFDNUUsa0JBQWtCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsZUFBZSxDQUFDLENBQUM7YUFDbkU7aUJBQU07Z0JBQ0wsa0JBQWtCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDOUQ7U0FDRjthQUFNO1lBQ0wsa0JBQWtCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDekQ7SUFDSCxDQUFDOzs7Ozs7O0lBR08sZ0JBQWdCLENBQUMsVUFBbUI7UUFDMUMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEVBQUU7WUFDOUUsSUFBSSxVQUFVLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDM0Q7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDMUQ7U0FDRjtJQUNILENBQUM7OztZQS9lRixTQUFTLFNBQUM7O2dCQUVULFFBQVEsRUFBRSx3QkFBd0I7Z0JBQ2xDLDRuTkFBaUQ7O2FBRWxEOzs7Ozt3QkFhRSxLQUFLO29CQUdMLEtBQUs7dUJBR0wsS0FBSzt1QkFHTCxLQUFLOzZCQUtMLEtBQUs7c0JBR0wsS0FBSzt1QkFLTCxLQUFLOzZCQUtMLEtBQUs7d0JBR0wsS0FBSzt5QkFLTCxLQUFLOytCQUtMLEtBQUs7dUJBR0wsS0FBSzsyQkFHTCxLQUFLO3dCQUtMLEtBQUs7OEJBS0wsS0FBSztvQkFJTCxLQUFLOzJCQWtCTCxLQUFLO3VCQW1DTCxLQUFLO2lDQXVCTCxLQUFLOzhCQUtMLEtBQUs7cUNBR0wsS0FBSzs4QkFLTCxLQUFLO2lDQUdMLEtBQUs7c0JBR0wsS0FBSztrQ0FHTCxLQUFLO3NCQUdMLEtBQUs7a0NBR0wsS0FBSzs7Ozs7OztJQXpLTiw0Q0FBK0M7Ozs7O0lBQy9DLG9EQUEwRDs7SUFDMUQsZ0RBQXFCOzs7OztJQUdyQiw2Q0FBOEI7Ozs7O0lBRzlCLHlDQUF1Qjs7Ozs7SUFHdkIsNENBQXlCOzs7OztJQUd6Qiw0Q0FBMEI7Ozs7OztJQUsxQixrREFBZ0M7Ozs7O0lBR2hDLDJDQUF5Qjs7Ozs7O0lBS3pCLDRDQUEyQjs7Ozs7O0lBSzNCLGtEQUErQjs7Ozs7SUFHL0IsNkNBQTJCOzs7Ozs7SUFLM0IsOENBQTZCOzs7Ozs7SUFLN0Isb0RBQWlDOzs7OztJQUdqQyw0Q0FBMEI7Ozs7O0lBRzFCLGdEQUErQjs7Ozs7O0lBSy9CLDZDQUE2Qjs7Ozs7O0lBSzdCLG1EQUFrQzs7Ozs7SUFJbEMseUNBQW9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0JwQixnREFhRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFzQkYsNENBaUJFOzs7Ozs7O0lBTUYsc0RBQW9DOzs7Ozs7SUFLcEMsbURBQTJDOzs7OztJQUczQywwREFBeUM7Ozs7OztJQUt6QyxtREFBMEc7Ozs7O0lBRzFHLHNEQUFxQzs7Ozs7SUFHckMsMkNBQTBCOzs7OztJQUcxQix1REFBc0M7Ozs7O0lBR3RDLDJDQUEwQjs7Ozs7SUFHMUIsdURBQXFDOztJQXlEckMsK0RBUUM7O0lBRUQsK0RBU0M7O0lBb0JELDREQXNCQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEFuZ3VsYXJcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCwgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTZWxlY3RJdGVtIH0gZnJvbSAncHJpbWVuZy9hcGknO1xuaW1wb3J0IHsgRGF0ZUVycm9yTWVzc2FnZSB9IGZyb20gJy4uL21vZGVscy9kYXRlLWVycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCBzdGFydFdpdGgsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgY29tcG9uZW50TmVlZHNSZXNvbHV0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9zcmMvbWV0YWRhdGEvcmVzb3VyY2VfbG9hZGluZyc7XG5cbkBDb21wb25lbnQoe1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGNvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ2FuZWYtaW5wdXQtZGF0ZS1hcHByb3gnLFxuICB0ZW1wbGF0ZVVybDogJy4vaW5wdXQtZGF0ZS1hcHByb3guY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9pbnB1dC1kYXRlLWFwcHJveC5jb21wb25lbnQuc2NzcyddLFxufSlcblxuLyoqXG4gKiBSZWFjdGl2ZUZvcm0gRGF0ZSBJbnB1dCAtIFPDqWpvdXJcbiAqIENvbXBvc2VkIHdpdGggYSB0ZXh0IGlucHV0IGZvciB0aGUgZGF5LCBhIGRyb3Bkb3duIGZvciB0aGUgbW9udGgsIGEgdGV4dCBpbnB1dCBmb3IgdGhlIHllYXJcbiAqIEFwcHJveGltYXRpdmUgZGF0ZSBvcHRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0RGF0ZUFwcHJveENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIG5vdGlmaWVyOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIHVua25vd25Nb250aEl0ZW0gPSB7bGFiZWw6ICdJbmNvbm51JywgdmFsdWU6ICdpJ307XG4gIGlzRGF0ZUFwcHJveCA9IGZhbHNlO1xuXG4gIC8qKiBGb3JtR3JvdXAgbmFtZSAqL1xuICBASW5wdXQoKSBmb3JtR3JvdXA6IEZvcm1Hcm91cDtcblxuICAvKiogRm9ybUdyb3VwIGxhYmVsICovXG4gIEBJbnB1dCgpIGxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIElzIEZvcm1Hcm91cCByZXF1aXJlZCAqL1xuICBASW5wdXQoKSByZXF1aXJlZCA9IHRydWU7XG5cbiAgLyoqIElzIEZvcm1Hcm91cCByZWFkb25seSAqL1xuICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xuXG4gIC8qKiBEZWZhdWx0IGRhdGUgdmFsdWUgZGlzcGxheWVkIGluIHJlYWRvbmx5IG1vZGVcbiAgICogQGRlZmF1bHQgJ04vQSdcbiAgICovXG4gIEBJbnB1dCgpIGRlZmF1bHREaXNwbGF5ID0gJ04vQSc7XG5cbiAgLyoqIEZvcm1Hcm91cCBkYXkgY29udHJvbCBuYW1lICovXG4gIEBJbnB1dCgpIGRheU5hbWU6IHN0cmluZztcblxuICAvKiogRm9ybUdyb3VwIGRheSBjb250cm9sIGxhYmVsXG4gICAqIEBkZWZhdWx0ICdKb3VyJ1xuICAgKi9cbiAgQElucHV0KCkgZGF5TGFiZWwgPSAnSm91cic7XG5cbiAgLyoqIEZvcm1Hcm91cCBkYXkgY29udHJvbCBwbGFjZWhvbGRlclxuICAgKiBAZGVmYXVsdCAnSkonXG4gICAqL1xuICBASW5wdXQoKSBkYXlQbGFjZWhvbGRlciA9ICdKSic7XG5cbiAgLyoqIEZvcm1Hcm91cCBtb250aCBjb250cm9sIG5hbWUgKi9cbiAgQElucHV0KCkgbW9udGhOYW1lOiBzdHJpbmc7XG5cbiAgLyoqIEZvcm1Hcm91cCBtb250aCBjb250cm9sIGxhYmVsXG4gICAqIEBkZWZhdWx0ICdNb2lzJ1xuICAgKi9cbiAgQElucHV0KCkgbW9udGhMYWJlbCA9ICdNb2lzJztcblxuICAvKiogRm9ybUdyb3VwIGRheSBjb250cm9sIHBsYWNlaG9sZGVyXG4gICAqIEBkZWZhdWx0ICdNTSdcbiAgICovXG4gIEBJbnB1dCgpIG1vbnRoUGxhY2Vob2xkZXIgPSAnTU0nO1xuXG4gIC8qKiBGb3JtR3JvdXAgeWVhciBjb250cm9sIG5hbWUgKi9cbiAgQElucHV0KCkgeWVhck5hbWU6IHN0cmluZztcblxuICAvKiogUHV0cyBhIHJlcXVpcmVkICogbWFyayBhc2lkZSB0aGUgeWVhciBjb250cm9sICovXG4gIEBJbnB1dCgpIHllYXJSZXF1aXJlZDogYm9vbGVhbjtcblxuICAvKiogRm9ybUdyb3VwIHllYXIgY29udHJvbCBsYWJlbFxuICAgKiBAZGVmYXVsdCAnQW5uw6llJ1xuICAgKi9cbiAgQElucHV0KCkgeWVhckxhYmVsID0gJ0FubsOpZSc7XG5cbiAgLyoqIEZvcm1Hcm91cCB5ZWFyIGNvbnRyb2wgcGxhY2Vob2xkZXJcbiAgICogQGRlZmF1bHQgJ0FBQUEnXG4gICAqL1xuICBASW5wdXQoKSB5ZWFyUGxhY2Vob2xkZXIgPSAnQUFBQSc7XG5cbiAgLyoqIG1vZGVsIHByb3BlcnR5IGZvciB1c2FnZSB3aXRoIG5nTW9kZWwgdG8gYmUgZGVmaW5lZFxuICAgKi9cbiAgQElucHV0KCkgbW9kZWw6IGFueTtcblxuICAvKiogRm9ybUdyb3VwIG1vbnRoIGNvbnRyb2wgZHJvcGRvd24gb3B0aW9uc1xuICAgKiBAZGVmYXVsdCBTZWxlY3RJdGVtW10gPSBbXG4gICAqIHsgbGFiZWw6ICdKYW52aWVyJywgdmFsdWU6IDEgfSxcbiAgICogeyBsYWJlbDogJ0bDqXZyaWVyJywgdmFsdWU6IDIgfSxcbiAgICogeyBsYWJlbDogJ01hcnMnLCB2YWx1ZTogMyB9LFxuICAgKiB7IGxhYmVsOiAnQXZyaWwnLCB2YWx1ZTogNCB9LFxuICAgKiB7IGxhYmVsOiAnTWFpJywgdmFsdWU6IDUgfSxcbiAgICogeyBsYWJlbDogJ0p1aW4nLCB2YWx1ZTogNiB9LFxuICAgKiB7IGxhYmVsOiAnSnVpbGxldCcsIHZhbHVlOiA3IH0sXG4gICAqIHsgbGFiZWw6ICdBb8O7dCcsIHZhbHVlOiA4IH0sXG4gICAqIHsgbGFiZWw6ICdTZXB0ZW1icmUnLCB2YWx1ZTogOSB9LFxuICAgKiB7IGxhYmVsOiAnT2N0b2JyZScsIHZhbHVlOiAxMCB9LFxuICAgKiB7IGxhYmVsOiAnTm92ZW1icmUnLCB2YWx1ZTogMTEgfSxcbiAgICogeyBsYWJlbDogJ0TDqWNlbWJyZScsIHZhbHVlOiAxMiB9XG4gICAqIF1cbiAgICovXG4gIEBJbnB1dCgpIG1vbnRoT3B0aW9uczogU2VsZWN0SXRlbVtdID0gW1xuICAgIHsgbGFiZWw6ICdKYW52aWVyJywgdmFsdWU6IDEgfSxcbiAgICB7IGxhYmVsOiAnRsOpdnJpZXInLCB2YWx1ZTogMiB9LFxuICAgIHsgbGFiZWw6ICdNYXJzJywgdmFsdWU6IDMgfSxcbiAgICB7IGxhYmVsOiAnQXZyaWwnLCB2YWx1ZTogNCB9LFxuICAgIHsgbGFiZWw6ICdNYWknLCB2YWx1ZTogNSB9LFxuICAgIHsgbGFiZWw6ICdKdWluJywgdmFsdWU6IDYgfSxcbiAgICB7IGxhYmVsOiAnSnVpbGxldCcsIHZhbHVlOiA3IH0sXG4gICAgeyBsYWJlbDogJ0Fvw7t0JywgdmFsdWU6IDggfSxcbiAgICB7IGxhYmVsOiAnU2VwdGVtYnJlJywgdmFsdWU6IDkgfSxcbiAgICB7IGxhYmVsOiAnT2N0b2JyZScsIHZhbHVlOiAxMCB9LFxuICAgIHsgbGFiZWw6ICdOb3ZlbWJyZScsIHZhbHVlOiAxMSB9LFxuICAgIHsgbGFiZWw6ICdEw6ljZW1icmUnLCB2YWx1ZTogMTIgfVxuICBdO1xuXG4gIC8qKiBGb3JtR3JvdXAgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlc1xuICAgKiBAZGVmYXVsdCAgRGF0ZUVycm9yTWVzc2FnZSA9IHtcbiAgICogICAgIGRheToge1xuICAgKiAgICAgICByZXF1aXJlZDogJ0xlIGpvdXIgZXN0IHJlcXVpcycsXG4gICAqICAgICAgIHBhdHRlcm46ICdMZSBqb3VyIGRvaXQgw6p0cmUgdW4gbm9tYnJlJyxcbiAgICogICAgICAgbGVuZ3RoOiAnTGUgam91ciBkb2l0IGNvbnRlbmlyIDIgY2hpZmZyZXMgYXUgbWF4aW11bScsXG4gICAqICAgICAgIG1pbk1heDogJ0xlIGpvdXIgZG9pdCDDqnRyZSBjb21wcmlzIGVudHJlIDEgZXQgMzEnXG4gICAqICAgICB9LFxuICAgKiAgICAgbW9udGg6IHtcbiAgICogICAgICAgcmVxdWlyZWQ6ICdMZSBtb2lzIGVzdCByZXF1aXMnXG4gICAqICAgICB9LFxuICAgKiAgICAgeWVhcjoge1xuICAgKiAgICAgICByZXF1aXJlZDogJ0xcXCdhbm7DqWUgZXN0IHJlcXVpc2UnLFxuICAgKiAgICAgICBwYXR0ZXJuOiAnTFxcJ2FubsOpZSBkb2l0IMOqdHJlIHVuIG5vbWJyZScsXG4gICAqICAgICAgIGxlbmd0aDogJ0xcXCdhbm7DqWUgZG9pdCBjb250ZW5pciA0IGNoaWZmcmVzJ1xuICAgKiAgICAgfSxcbiAgICogICAgIGludmFsaWQ6ICdMYSBkYXRlIGVzdCBpbnZhbGlkZScsXG4gICAqICAgICByZXF1aXJlZDogJ0NlIGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS4nXG4gICAqICAgfVxuICAgKi9cbiAgQElucHV0KCkgbWVzc2FnZXM6IERhdGVFcnJvck1lc3NhZ2UgPSB7XG4gICAgZGF5OiB7XG4gICAgICByZXF1aXJlZDogJ0xlIGpvdXIgZXN0IHJlcXVpcycsXG4gICAgICBwYXR0ZXJuOiAnTGUgam91ciBkb2l0IMOqdHJlIHVuIG5vbWJyZScsXG4gICAgICBsZW5ndGg6ICdMZSBqb3VyIGRvaXQgY29udGVuaXIgMiBjaGlmZnJlcyBhdSBtYXhpbXVtJyxcbiAgICAgIG1pbk1heDogJ0xlIGpvdXIgZG9pdCDDqnRyZSBjb21wcmlzIGVudHJlIDEgZXQgMzEnXG4gICAgfSxcbiAgICBtb250aDoge1xuICAgICAgcmVxdWlyZWQ6ICdMZSBtb2lzIGVzdCByZXF1aXMnXG4gICAgfSxcbiAgICB5ZWFyOiB7XG4gICAgICByZXF1aXJlZDogJ0xcXCdhbm7DqWUgZXN0IHJlcXVpc2UnLFxuICAgICAgcGF0dGVybjogJ0xcXCdhbm7DqWUgZG9pdCDDqnRyZSB1biBub21icmUnLFxuICAgICAgbGVuZ3RoOiAnTFxcJ2FubsOpZSBkb2l0IGNvbnRlbmlyIDQgY2hpZmZyZXMnXG4gICAgfSxcbiAgICBpbnZhbGlkOiAnTGEgZGF0ZSBlc3QgaW52YWxpZGUnLFxuICAgIHJlcXVpcmVkOiAnQ2UgY2hhbXAgZXN0IG9ibGlnYXRvaXJlLidcbiAgfTtcblxuICAvKiogQ2FuIHRoZSBkYXRlIGJlIGFwcHJveGltYXRpdmUgb3Igbm90XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEB1c2FnZSBbY2FuQmVBcHByb3hpbWF0aXZlXT1cInRydWVcIlxuICAgKi9cbiAgQElucHV0KCkgY2FuQmVBcHByb3hpbWF0aXZlID0gZmFsc2U7XG5cbiAgIC8qKiBGb3JtR3JvdXAgYXBwcm94aW1hdGl2ZSBkYXRlIGxhYmVsXG4gICAgKiBAZGVmYXVsdCAnQXBwcm94aW1hdGl2ZSdcbiAgICAqL1xuICBASW5wdXQoKSBkYXRlQXBwcm94TGFiZWwgPSAnQXBwcm94aW1hdGl2ZSc7XG5cbiAgLyoqIEZvcm1Hcm91cCBhcHByb3hpbWF0aXZlIGRhdGUgY2hlY2tib3ggY29udHJvbCBuYW1lLCByZXF1aXJlZCBpZiBhcHByb3hpbWF0aXZlIGRhdGUgKi9cbiAgQElucHV0KCkgZGF0ZUFwcHJveENoZWNrYm94TmFtZT86IHN0cmluZztcblxuICAvKiogQXBwcm94aW1hdGl2ZSBkYXRlIGZvcm1hdFxuICAgKiBAdmFsdWVzIHtrbm93bjogJ0ZGL0ZGL0ZGRkYnLCBkYXlVbmtub3duOiAnMDAvRkYvRkZGRicsIGRheU1vbnRoVW5rbm93bjogJzAwLzAwL0ZGRkYnfVxuICAgKi9cbiAgQElucHV0KCkgZGF0ZUFwcHJveE1hc2tzID0ge2tub3duOiAnRkYvRkYvRkZGRicsIGRheVVua25vd246ICcwMC9GRi9GRkZGJywgZGF5TW9udGhVbmtub3duOiAnMDAvMDAvRkZGRid9O1xuXG4gIC8qKiBGb3JtR3JvdXAgYXBwcm94aW1hdGl2ZSBkYXRlIG1hc2sgaGlkZGVuIGNvbnRyb2wgbmFtZSwgcmVxdWlyZWQgaWYgYXBwcm94aW1hdGl2ZSBkYXRlICovXG4gIEBJbnB1dCgpIGRhdGVBcHByb3hNYXNrTmFtZT86IHN0cmluZztcblxuICAvKiogbWF4IHZhbHVlIGZvciBkYXRlIEREL01NL1lZWSBvciAnbm93JyAqL1xuICBASW5wdXQoKSBtYXhEYXRlPyA6IHN0cmluZ1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGlmIGRhdGUgPiBtYXggdmFsdWUgKi9cbiAgQElucHV0KCkgbWF4RGF0ZUVycm9yTWVzc2FnZT8gOiBzdHJpbmdcblxuICAvKiogbWluIHZhbHVlIGZvciBkYXRlIEREL01NL1lZWSAgKi9cbiAgQElucHV0KCkgbWluRGF0ZT8gOiBzdHJpbmdcblxuICAvKiogRXJyb3IgbWVzc2FnZSBpZiBkYXRlIDwgbWluIHZhbHVlICovXG4gIEBJbnB1dCgpIG1pbkRhdGVFcnJvck1lc3NhZ2U/IDpzdHJpbmdcblxuICBjb25zdHJ1Y3RvcigpIHt9XG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiggY2hhbmdlc1sncmVhZG9ubHknXSAmJiBjaGFuZ2VzWydyZWFkb25seSddLnByZXZpb3VzVmFsdWUgIT0gY2hhbmdlc1sncmVhZG9ubHknXS5jdXJyZW50VmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0Q2hlY2tib3hTdHlsZShjaGFuZ2VzWydyZWFkb25seSddLmN1cnJlbnRWYWx1ZSk7XG4gICAgICBpZiAodGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF0ZUFwcHJveE1hc2tOYW1lKSAmJiB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXRlQXBwcm94TWFza05hbWUpLnZhbHVlID09PSB0aGlzLmRhdGVBcHByb3hNYXNrcy5kYXlNb250aFVua25vd24pIHtcblxuICAgICAgICB0aGlzLmVkaXRNb250aE9wdGlvbnModHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnJlYWRvbmx5KSB7XG4gICAgICB0aGlzLmFkZERheUNvbnRyb2xNaW5NYXhWYWxpZGF0b3IoKTtcbiAgICAgIHRoaXMuYWRkRm9ybUdyb3VwVmFsaWRhdG9ycygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbkJlQXBwcm94aW1hdGl2ZSAmJiB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXRlQXBwcm94Q2hlY2tib3hOYW1lKSkge1xuICAgICAgdGhpcy5kYXRlQXBwcm94Q2hlY2tib3hDaGFuZ2UoKTtcbiAgICAgIHRoaXMubW9udGhPcHRpb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBhZGREYXlDb250cm9sTWluTWF4VmFsaWRhdG9yKCkge1xuICAgIGNvbnN0IHZhbGlkYXRvcnNBcnJheSA9IFtdO1xuXG4gICAgdmFsaWRhdG9yc0FycmF5LnB1c2goVmFsaWRhdG9ycy5taW4oMSksIFZhbGlkYXRvcnMubWF4KDMxKSlcblxuICAgIGlmICh0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXlOYW1lKS52YWxpZGF0b3IpIHtcbiAgICAgIHZhbGlkYXRvcnNBcnJheS5wdXNoKHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRheU5hbWUpLnZhbGlkYXRvcik7XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF5TmFtZSkuc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzQXJyYXkpO1xuICAgIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRheU5hbWUpLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgfVxuXG4gIGFkZEZvcm1Hcm91cFZhbGlkYXRvcnMoKSB7XG4gICAgY29uc3QgdmFsaWRhdG9yc0FycmF5ID0gW107XG5cbiAgICB2YWxpZGF0b3JzQXJyYXkucHVzaCh0aGlzLmNyb3NzRmllbGRzRGF0ZVZhbGlkYXRvcik7XG5cbiAgICBpZiAodGhpcy5taW5EYXRlICYmIHRoaXMubWluRGF0ZUVycm9yTWVzc2FnZSkge1xuICAgICAgdmFsaWRhdG9yc0FycmF5LnB1c2godGhpcy5jcm9zc0ZpZWxkc01pbkRhdGVWYWxpZGF0b3IpXG4gICAgfVxuICAgIGlmKHRoaXMubWF4RGF0ZSAmJiB0aGlzLm1heERhdGVFcnJvck1lc3NhZ2UpIHtcbiAgICAgIHZhbGlkYXRvcnNBcnJheS5wdXNoKHRoaXMuY3Jvc3NGaWVsZHNNYXhEYXRlVmFsaWRhdG9yKVxuICAgIH1cbiAgICBpZih0aGlzLmZvcm1Hcm91cC52YWxpZGF0b3IpIHtcbiAgICAgIHZhbGlkYXRvcnNBcnJheS5wdXNoKHRoaXMuZm9ybUdyb3VwLnZhbGlkYXRvcilcbiAgICB9XG5cbiAgICB0aGlzLmZvcm1Hcm91cC5zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnNBcnJheSk7XG4gICAgdGhpcy5mb3JtR3JvdXAudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICB9XG5cbiAgY3Jvc3NGaWVsZHNNaW5EYXRlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChmZzogRm9ybUdyb3VwKSA9PiB7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5nZXRGaWVsZHMoKTtcbiAgICBpZihtb21lbnQoW2ZpZWxkcy55ZWFyLCBmaWVsZHMubW9udGgsIGZpZWxkcy5kYXldKS5pc1ZhbGlkKCkgJiYgIXRoaXMuZm9ybUNvbnRhaW5zRXJyb3JzKCkpe1xuICAgICAgaWYobW9tZW50KFtmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF5XSkgPCBtb21lbnQodGhpcy5taW5EYXRlLCAnREQvTU0vWVlZWScpKSB7XG4gICAgICAgIHJldHVybiB7IHRvb09sZCA6IHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNyb3NzRmllbGRzTWF4RGF0ZVZhbGlkYXRvcjogVmFsaWRhdG9yRm4gPSAoZmc6IEZvcm1Hcm91cCkgPT4ge1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RmllbGRzKCk7XG4gICAgaWYobW9tZW50KFtmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF5XSkuaXNWYWxpZCgpICYmICF0aGlzLmZvcm1Db250YWluc0Vycm9ycygpKXtcbiAgICAgIGNvbnN0IGRhdGUgPSBtb21lbnQoW2ZpZWxkcy55ZWFyLCBmaWVsZHMubW9udGgsIGZpZWxkcy5kYXldKTtcbiAgICAgIGlmKHRoaXMubWF4RGF0ZSA9PT0gJ25vdycgJiYgZGF0ZSA+IG1vbWVudCgpIHx8IGRhdGUgPiBtb21lbnQodGhpcy5tYXhEYXRlLCAnREQvTU0vWVlZWScpKSB7XG4gICAgICAgIHJldHVybiB7IHRvb0Z1dHVyZSA6IHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RmllbGRzKCkge1xuICAgIHJldHVybiB7IGRheTogdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF5TmFtZSkudmFsdWUsIG1vbnRoOiB0aGlzLmdldE1vbnRoVmFsdWUodHJ1ZSksIHllYXI6IHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLnllYXJOYW1lKS52YWx1ZSB9XG4gIH1cblxuICBhcmVGaWVsZHNFbXB0eSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgIHJldHVybiAhZmllbGRzLmRheSAmJiAhZmllbGRzLm1vbnRoICYmICFmaWVsZHMueWVhcjtcbiAgfVxuXG4gIGFyZUZpZWxkc0ZpbGxlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgIHJldHVybiBmaWVsZHMuZGF5ICE9IG51bGwgJiYgZmllbGRzLm1vbnRoID4gLTEgJiYgZmllbGRzLnllYXIgIT0gbnVsbDtcbiAgfVxuXG4gIGFyZUZpZWxkc1RvdWNoZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLnllYXJOYW1lKS50b3VjaGVkICYmIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLnllYXJOYW1lKS50b3VjaGVkICYmIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLnllYXJOYW1lKS50b3VjaGVkO1xuICB9XG5cbiAgY3Jvc3NGaWVsZHNEYXRlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChmZzogRm9ybUdyb3VwKSA9PiB7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5nZXRGaWVsZHMoKTtcbiAgICBpZiAoIW1vbWVudChbZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRheV0pLmlzVmFsaWQoKSkge1xuICAgICAgaWYgKHRoaXMuYXJlRmllbGRzRmlsbGVkKCkpe1xuICAgICAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy55ZWFyTmFtZSkuc2V0RXJyb3JzKHsgaW52YWxpZERhdGU6IHRydWUgfSwgeyBlbWl0RXZlbnQ6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLm1vbnRoTmFtZSkuc2V0RXJyb3JzKHsgaW52YWxpZERhdGU6IHRydWUgfSwgeyBlbWl0RXZlbnQ6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRheU5hbWUpLnNldEVycm9ycyh7IGludmFsaWREYXRlOiB0cnVlIH0sIHsgZW1pdEV2ZW50OiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvcm1Hcm91cC5zZXRFcnJvcnMoeyBpbnZhbGlkRGF0ZTogdHJ1ZSB9KTtcblxuICAgICAgaWYgKCh0aGlzLnJlcXVpcmVkIHx8IHRoaXMueWVhclJlcXVpcmVkICkgJiYgdGhpcy5hcmVGaWVsZHNGaWxsZWQoKSkge1xuICAgICAgICByZXR1cm4geyBpbnZhbGlkRGF0ZSA6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vbWVudChbZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRheV0pLmlzVmFsaWQoKSl7XG4gICAgICB0aGlzLmZvcm1Hcm91cC5zZXRFcnJvcnMobnVsbCk7XG4gICAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy55ZWFyTmFtZSkuc2V0RXJyb3JzKG51bGwpO1xuICAgICAgdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMubW9udGhOYW1lKS5zZXRFcnJvcnMobnVsbCk7XG4gICAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXlOYW1lKS5zZXRFcnJvcnMobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5ub3RpZmllci5uZXh0KCk7XG4gICAgdGhpcy5ub3RpZmllci51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBmb3JtIGlzIGludmFsaWQgKi9cbiAgZm9ybUNvbnRhaW5zRXJyb3JzKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNvbnRyb2xOYW1lcyA9IFt0aGlzLmRheU5hbWUsIHRoaXMubW9udGhOYW1lLCB0aGlzLnllYXJOYW1lXTtcbiAgICByZXR1cm4gY29udHJvbE5hbWVzLnNvbWUoY29udHJvbE5hbWUgPT4gIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xDb250YWluc0Vycm9ycyhjb250cm9sTmFtZSkgfSkgO1xuICB9XG5cbiAgZm9ybUVycm9yKCk6IGJvb2xlYW4ge1xuICAgICByZXR1cm4gdGhpcy5mb3JtR3JvdXAudG91Y2hlZCAmJiB0aGlzLmZvcm1Hcm91cC5lcnJvcnMgIT09IG51bGw7XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIGEgY29udHJvbCBpcyBpbnZhbGlkICovXG4gIGNvbnRyb2xDb250YWluc0Vycm9ycyhjb250cm9sTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybUdyb3VwICYmICh0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tjb250cm9sTmFtZV0uZXJyb3JzICE9PSBudWxsICYmICh0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tjb250cm9sTmFtZV0uZGlydHkgfHwgdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbY29udHJvbE5hbWVdLnRvdWNoZWQpKTtcbiAgfVxuICAvKiogUmV0dXJucyB0cnVlIGlmIGNvbnRyb2wgdmFsdWUgaGFzIHBhdHRlcm4gZXJyb3JzICovXG4gIGhhc1BhdHRlcm5FcnJvcihjb250cm9sTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENvbnRhaW5zRXJyb3JzKGNvbnRyb2xOYW1lKSAmJiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tjb250cm9sTmFtZV0uZXJyb3JzLnBhdHRlcm47XG4gIH1cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBjb250cm9sIHZhbHVlIGlzIGluZmVyaW9yIHRvIGNvbnRyb2wgbWluIHZhbHVlIG9yIHN1cGVyaW9yIHRvIGNvbnRyb2wgbWF4IHZhbHVlICovXG4gIGhhc01pbk1heEVycm9yKGNvbnRyb2xOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ29udGFpbnNFcnJvcnMoY29udHJvbE5hbWUpICYmXG4gICAgICAodGhpcy5mb3JtR3JvdXAuY29udHJvbHNbY29udHJvbE5hbWVdLmVycm9ycy5taW4gfHwgdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbY29udHJvbE5hbWVdLmVycm9ycy5tYXgpO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgY29udHJvbCB2YWx1ZSBsZW5ndGggaXMgaW5mZXJpb3IgdG8gY29udHJvbCBtaW4gdmFsdWUgbGVuZ3RoIG9yIHN1cGVyaW9yIHRvIGNvbnRyb2wgbWF4IHZhbHVlIGxlbmd0aCAqL1xuICBoYXNMZW5ndGhFcnJvcihjb250cm9sTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENvbnRhaW5zRXJyb3JzKGNvbnRyb2xOYW1lKSAmJlxuICAgICAgKHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lcnJvcnMubWlubGVuZ3RoIHx8IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lcnJvcnMubWF4bGVuZ3RoKTtcbiAgfVxuICAvKiogUmV0dXJucyB0cnVlIGlmIGNvbnRyb2wgaXMgcmVxdWlyZWQgYnV0IG5vdCBmaWxsZWQgKi9cbiAgaGFzUmVxdWlyZWRFcnJvcihjb250cm9sTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENvbnRhaW5zRXJyb3JzKGNvbnRyb2xOYW1lKSAmJiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tjb250cm9sTmFtZV0uZXJyb3JzLnJlcXVpcmVkO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgY29udHJvbCBpcyBub3QgYSB2YWxpZCBkYXRlICovXG4gIGhhc0ludmFsaWREYXRlRXJyb3IoY29udHJvbE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDb250YWluc0Vycm9ycyhjb250cm9sTmFtZSkgJiYgdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbY29udHJvbE5hbWVdLmVycm9ycy5pbnZhbGlkRGF0ZTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgZm9ybSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgZGF0ZSAqL1xuICBoYXNGb3JtR3JvdXBJbnZhbGlkYXRlRXJyb3IoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybUdyb3VwLmVycm9ycyAmJiB0aGlzLmZvcm1Hcm91cC5lcnJvcnMuaW52YWxpZERhdGU7XG4gIH1cblxuICBoYXNGdXR1cmVEYXRlRXJyb3IoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybUdyb3VwLmVycm9ycyAmJiB0aGlzLmZvcm1Hcm91cC5lcnJvcnMudG9vRnV0dXJlO1xuICB9XG5cbiAgaGFzVG9vT2xkRGF0ZUVycm9yKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZvcm1Hcm91cC5lcnJvcnMgJiYgdGhpcy5mb3JtR3JvdXAuZXJyb3JzLnRvb09sZDtcblxuICB9XG5cbiAgaXNBbGxGaWVsZHNGaWxsZWQoKSA6Ym9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGFzUmVxdWlyZWRFcnJvcih0aGlzLnllYXJOYW1lKVxuICAgICAgICAmJiB0aGlzLmhhc1JlcXVpcmVkRXJyb3IodGhpcy5tb250aE5hbWUpXG4gICAgICAgICYmIHRoaXMuaGFzUmVxdWlyZWRFcnJvcih0aGlzLmRheU5hbWUpO1xuICB9XG5cbiAgLyoqKiBSZXR1cm5zIEZvcm1Hcm91cCBtb250aCBmaWVsZCB2YWx1ZSAqL1xuICBwcml2YXRlIGdldE1vbnRoVmFsdWUoY29ycmVjdEZvck1vbWVudD86IGJvb2xlYW4pIHtcbiAgICBsZXQgIHZhbHVlID0gdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMubW9udGhOYW1lKS52YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMudW5rbm93bk1vbnRoSXRlbS52YWx1ZSkge1xuICAgICAgdmFsdWUgPSAxO1xuICAgIH1cbiAgICBpZiAoY29ycmVjdEZvck1vbWVudCkge1xuICAgICAgcmV0dXJuIHZhbHVlIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqIEZvcm1hdCBkYXRlIHRvIHN0cmluZyBmb3IgZGlzcGxheSAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgZGF0ZVN0cmluZzogc3RyaW5nO1xuXG4gICAgY29uc3QgZGF5ID0gdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF5TmFtZSkudmFsdWU7XG4gICAgY29uc3QgbW9udGggPSB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5tb250aE5hbWUpLnZhbHVlO1xuICAgIGNvbnN0IHllYXIgPSB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy55ZWFyTmFtZSkudmFsdWU7XG5cbiAgICBjb25zdCBub25BcHByb3hBbmRFbXB0eSA9ICF0aGlzLmlzRGF0ZUFwcHJveCAmJiAhZGF5ICYmICFtb250aCAmJiAheWVhcjtcbiAgICBjb25zdCBhcHByb3hBbmRFbXB0eSA9IHRoaXMuaXNEYXRlQXBwcm94ICYmICFtb250aCAmJiAheWVhcjtcblxuICAgIGlmIChub25BcHByb3hBbmRFbXB0eSB8fCBhcHByb3hBbmRFbXB0eSkge1xuICAgICAgZGF0ZVN0cmluZyA9ICB0aGlzLmRlZmF1bHREaXNwbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBtb21lbnQudXBkYXRlTG9jYWxlKG1vbWVudC5sb2NhbGUoKSwgeyBpbnZhbGlkRGF0ZTogdGhpcy5kZWZhdWx0RGlzcGxheSB9KTtcbiAgICAgIGRhdGVTdHJpbmcgPSBtb21lbnQoW051bWJlcih5ZWFyKSwgTnVtYmVyKHRoaXMuZ2V0TW9udGhWYWx1ZSh0cnVlKSksIE51bWJlcihkYXkpXSkuZm9ybWF0KCdERC9NTS9ZWVlZJyk7XG5cbiAgICAgIGlmICghbm9uQXBwcm94QW5kRW1wdHkgJiYgIXRoaXMuaXNEYXRlQXBwcm94KSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyaW5nO1xuICAgICAgfSBlbHNlIGlmICghYXBwcm94QW5kRW1wdHkgJiYgdGhpcy5pc0RhdGVBcHByb3gpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRhdGVBcHByb3hNYXNrTmFtZSkudmFsdWU7XG4gICAgICAgIGNvbnN0IGRhdGVTdHJpbmdBcnJheSA9IGRhdGVTdHJpbmcuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKG1hc2sgPT09IHRoaXMuZGF0ZUFwcHJveE1hc2tzLmRheVVua25vd24pIHtcbiAgICAgICAgICBkYXRlU3RyaW5nQXJyYXlbMF0gPSAnLSc7XG4gICAgICAgIH0gZWxzZSBpZiAobWFzayA9PT0gdGhpcy5kYXRlQXBwcm94TWFza3MuZGF5TW9udGhVbmtub3duKSB7XG4gICAgICAgICAgZGF0ZVN0cmluZ0FycmF5WzBdID0gJy0nO1xuICAgICAgICAgIGRhdGVTdHJpbmdBcnJheVsxXSA9ICctJztcbiAgICAgICAgfVxuICAgICAgICBkYXRlU3RyaW5nID0gZGF0ZVN0cmluZ0FycmF5LmpvaW4oJy8nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGVTdHJpbmc7XG4gIH1cblxuICAvKiogVHJpZ2dlcnMgZGF0ZSBhcHByb3ggZWRpdGluZyBmdW5jdGlvbnMgZm9sbG93aW5nIGRhdGUgYXBwcm94IGNoZWNrYm94IHZhbHVlcyAqL1xuICBwcml2YXRlIGRhdGVBcHByb3hDaGVja2JveENoYW5nZSgpIHtcbiAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXRlQXBwcm94Q2hlY2tib3hOYW1lKS52YWx1ZUNoYW5nZXNcbiAgICAucGlwZShcbiAgICAgIHN0YXJ0V2l0aCh0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXRlQXBwcm94Q2hlY2tib3hOYW1lKS52YWx1ZSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgdGFrZVVudGlsKHRoaXMubm90aWZpZXIpXG4gICAgICApXG4gICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgIHRoaXMuaXNEYXRlQXBwcm94ID0gdmFsdWU7XG4gICAgICB0aGlzLnNldERheVZhbHVlKHZhbHVlKTtcbiAgICAgIHRoaXMuZWRpdE1vbnRoT3B0aW9ucyh2YWx1ZSk7XG4gICAgICB0aGlzLnNldERhdGVBcHByb3hNYXNrKHZhbHVlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIFRyaWdnZXJzIFNldERhdGVBcHByb3hNQXNrIG9uIG1vbnRoT3B0aW9ucyBjaGFuZ2UgKi9cbiAgcHJpdmF0ZSBtb250aE9wdGlvbkNoYW5nZSgpIHtcbiAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5tb250aE5hbWUpLnZhbHVlQ2hhbmdlc1xuICAgIC5waXBlKFxuICAgICAgc3RhcnRXaXRoKHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLm1vbnRoTmFtZSkudmFsdWUpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIHRha2VVbnRpbCh0aGlzLm5vdGlmaWVyKVxuICAgICAgKVxuICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXREYXRlQXBwcm94TWFzayh0aGlzLmlzRGF0ZUFwcHJveCk7XG4gICAgICB0aGlzLmZvcm1Hcm91cC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBTZXRzIGRheSB2YWx1ZSB0byAxIGlmIGRhdGUgaXMgYXBwcm94aW1hdGl2ZSAqL1xuICBwcml2YXRlIHNldERheVZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXlOYW1lKS5zZXRWYWx1ZSgnMScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF0ZUFwcHJveENoZWNrYm94TmFtZSkuZGlydHkpIHtcbiAgICAgICAgdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF5TmFtZSkucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQWRkcyBvciByZW1vdmUgJ0luY29ubnUnIG1vbnRoIG9wdGlvbiAqL1xuICBwcml2YXRlIGVkaXRNb250aE9wdGlvbnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBoYXNVbmtub3duTW9udGhJdGVtID0gdGhpcy5tb250aE9wdGlvbnMuc29tZSggaXRlbSA9PiBpdGVtLnZhbHVlID09PSB0aGlzLnVua25vd25Nb250aEl0ZW0udmFsdWUpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFoYXNVbmtub3duTW9udGhJdGVtKSB7XG4gICAgICAgIHRoaXMubW9udGhPcHRpb25zLnVuc2hpZnQodGhpcy51bmtub3duTW9udGhJdGVtKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5kYXRlQXBwcm94TWFza05hbWUpLnZhbHVlID09PSB0aGlzLmRhdGVBcHByb3hNYXNrcy5kYXlNb250aFVua25vd24pIHtcbiAgICAgICAgdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMubW9udGhOYW1lKS5zZXRWYWx1ZSh0aGlzLnVua25vd25Nb250aEl0ZW0udmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzVW5rbm93bk1vbnRoSXRlbSkge1xuICAgICAgICB0aGlzLm1vbnRoT3B0aW9ucy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLm1vbnRoTmFtZSkudmFsdWUgPT09IHRoaXMudW5rbm93bk1vbnRoSXRlbS52YWx1ZSkge1xuICAgICAgICB0aGlzLmZvcm1Hcm91cC5nZXQodGhpcy5tb250aE5hbWUpLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgZGF0ZSBhcHByb3ggbWFzayAgKi9cbiAgcHJpdmF0ZSBzZXREYXRlQXBwcm94TWFzayh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IGRhdGVBcHByb3hNYXNrTmFtZSA9IHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRhdGVBcHByb3hNYXNrTmFtZSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMubW9udGhOYW1lKS52YWx1ZSA9PT0gdGhpcy51bmtub3duTW9udGhJdGVtLnZhbHVlKSB7XG4gICAgICAgIGRhdGVBcHByb3hNYXNrTmFtZS5zZXRWYWx1ZSh0aGlzLmRhdGVBcHByb3hNYXNrcy5kYXlNb250aFVua25vd24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZUFwcHJveE1hc2tOYW1lLnNldFZhbHVlKHRoaXMuZGF0ZUFwcHJveE1hc2tzLmRheVVua25vd24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlQXBwcm94TWFza05hbWUuc2V0VmFsdWUodGhpcy5kYXRlQXBwcm94TWFza3Mua25vd24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTZXQgYXBwcm94IGNoZWNrYm94IHN0eWxlIGluIHJlYWRvbmx5IG1vZGUgKi9cbiAgcHJpdmF0ZSBzZXRDaGVja2JveFN0eWxlKGlzUmVhZE9ubHk6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5jYW5CZUFwcHJveGltYXRpdmUgJiYgdGhpcy5mb3JtR3JvdXAuZ2V0KHRoaXMuZGF0ZUFwcHJveENoZWNrYm94TmFtZSkpIHtcbiAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRhdGVBcHByb3hDaGVja2JveE5hbWUpLmRpc2FibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm9ybUdyb3VwLmdldCh0aGlzLmRhdGVBcHByb3hDaGVja2JveE5hbWUpLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19